/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * FAST_BUFFERS_LICENSE file included in this Fast Buffers distribution.
 *
 *************************************************************************
 * 
 * @file JointTrajectory.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool fastbuffers.
 */

#include "JointTrajectory.h"

#include "fastcdr/FastCdr.h"
#include "fastcdr/exceptions/BadParamException.h"
using namespace eprosima::fastcdr::exception;

#include <utility>

duration::duration()
{
    m_sec = 0;
    m_nsec = 0;
}

duration::~duration()
{
}

duration::duration(const duration &x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
}

duration::duration(duration &&x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
}

duration& duration::operator=(const duration &x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
    
    return *this;
}

duration& duration::operator=(duration &&x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
    
    return *this;
}

size_t duration::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
            
    current_align += 4;
    current_align += 4;

    return current_align;
}

void duration::serialize(eprosima::fastcdr::FastCdr &scdr) const
{
    scdr << m_sec;

    scdr << m_nsec;

}

void duration::deserialize(eprosima::fastcdr::FastCdr &dcdr)
{
    dcdr >> m_sec;
    dcdr >> m_nsec;
}

JointTrajectoryPoint::JointTrajectoryPoint()
{





}

JointTrajectoryPoint::~JointTrajectoryPoint()
{
}

JointTrajectoryPoint::JointTrajectoryPoint(const JointTrajectoryPoint &x)
{
    m_positions = x.m_positions;
    m_velocities = x.m_velocities;
    m_accelerations = x.m_accelerations;
    m_effort = x.m_effort;
    m_time_from_start = x.m_time_from_start;
}

JointTrajectoryPoint::JointTrajectoryPoint(JointTrajectoryPoint &&x)
{
    m_positions = std::move(x.m_positions);
    m_velocities = std::move(x.m_velocities);
    m_accelerations = std::move(x.m_accelerations);
    m_effort = std::move(x.m_effort);
    m_time_from_start = std::move(x.m_time_from_start);
}

JointTrajectoryPoint& JointTrajectoryPoint::operator=(const JointTrajectoryPoint &x)
{
    m_positions = x.m_positions;
    m_velocities = x.m_velocities;
    m_accelerations = x.m_accelerations;
    m_effort = x.m_effort;
    m_time_from_start = x.m_time_from_start;
    
    return *this;
}

JointTrajectoryPoint& JointTrajectoryPoint::operator=(JointTrajectoryPoint &&x)
{
    m_positions = std::move(x.m_positions);
    m_velocities = std::move(x.m_velocities);
    m_accelerations = std::move(x.m_accelerations);
    m_effort = std::move(x.m_effort);
    m_time_from_start = std::move(x.m_time_from_start);
    
    return *this;
}

size_t JointTrajectoryPoint::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
            
    current_align += 4;
    current_align += (100 * 8);

    current_align += 4;
    current_align += (100 * 8);

    current_align += 4;
    current_align += (100 * 8);

    current_align += 4;
    current_align += (100 * 8);

    current_align = duration::getMaxCdrSerializedSize(current_align);

    return current_align;
}

void JointTrajectoryPoint::serialize(eprosima::fastcdr::FastCdr &scdr) const
{
    if(m_positions.size() <= 100)
    scdr << m_positions;
    else
    throw BadParamException(std::string("The maximum length was exceeded"));
    if(m_velocities.size() <= 100)
    scdr << m_velocities;
    else
    throw BadParamException(std::string("The maximum length was exceeded"));
    if(m_accelerations.size() <= 100)
    scdr << m_accelerations;
    else
    throw BadParamException(std::string("The maximum length was exceeded"));
    if(m_effort.size() <= 100)
    scdr << m_effort;
    else
    throw BadParamException(std::string("The maximum length was exceeded"));
    scdr << m_time_from_start;

}

void JointTrajectoryPoint::deserialize(eprosima::fastcdr::FastCdr &dcdr)
{
    dcdr >> m_positions;
    dcdr >> m_velocities;
    dcdr >> m_accelerations;
    dcdr >> m_effort;
    dcdr >> m_time_from_start;
}

time::time()
{
    m_sec = 0;
    m_nsec = 0;
}

time::~time()
{
}

time::time(const time &x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
}

time::time(time &&x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
}

time& time::operator=(const time &x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
    
    return *this;
}

time& time::operator=(time &&x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
    
    return *this;
}

size_t time::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
            
    current_align += 4;
    current_align += 4;

    return current_align;
}

void time::serialize(eprosima::fastcdr::FastCdr &scdr) const
{
    scdr << m_sec;

    scdr << m_nsec;

}

void time::deserialize(eprosima::fastcdr::FastCdr &dcdr)
{
    dcdr >> m_sec;
    dcdr >> m_nsec;
}

Header::Header()
{
    m_seq = 0;

    m_frame_id = "";
}

Header::~Header()
{
}

Header::Header(const Header &x)
{
    m_seq = x.m_seq;
    m_stamp = x.m_stamp;
    m_frame_id = x.m_frame_id;
}

Header::Header(Header &&x)
{
    m_seq = x.m_seq;
    m_stamp = std::move(x.m_stamp);
    m_frame_id = x.m_frame_id;
}

Header& Header::operator=(const Header &x)
{
    m_seq = x.m_seq;
    m_stamp = x.m_stamp;
    m_frame_id = x.m_frame_id;
    
    return *this;
}

Header& Header::operator=(Header &&x)
{
    m_seq = x.m_seq;
    m_stamp = std::move(x.m_stamp);
    m_frame_id = x.m_frame_id;
    
    return *this;
}

size_t Header::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
            
    current_align += 4;
    current_align = time::getMaxCdrSerializedSize(current_align);
    current_align += 255;

    return current_align;
}

void Header::serialize(eprosima::fastcdr::FastCdr &scdr) const
{
    scdr << m_seq;

    scdr << m_stamp;

    if(m_frame_id.length() <= 255)
    scdr << m_frame_id;
    else
    throw BadParamException(std::string("The maximum length was exceeded"));
}

void Header::deserialize(eprosima::fastcdr::FastCdr &dcdr)
{
    dcdr >> m_seq;
    dcdr >> m_stamp;
    dcdr >> m_frame_id;
}

JointTrajectory::JointTrajectory()
{



}

JointTrajectory::~JointTrajectory()
{
}

JointTrajectory::JointTrajectory(const JointTrajectory &x)
{
    m_header = x.m_header;
    m_joint_names = x.m_joint_names;
    m_points = x.m_points;
}

JointTrajectory::JointTrajectory(JointTrajectory &&x)
{
    m_header = std::move(x.m_header);
    m_joint_names = std::move(x.m_joint_names);
    m_points = std::move(x.m_points);
}

JointTrajectory& JointTrajectory::operator=(const JointTrajectory &x)
{
    m_header = x.m_header;
    m_joint_names = x.m_joint_names;
    m_points = x.m_points;
    
    return *this;
}

JointTrajectory& JointTrajectory::operator=(JointTrajectory &&x)
{
    m_header = std::move(x.m_header);
    m_joint_names = std::move(x.m_joint_names);
    m_points = std::move(x.m_points);
    
    return *this;
}

size_t JointTrajectory::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
            
    current_align = Header::getMaxCdrSerializedSize(current_align);
    current_align += 4;
    current_align += 100 * 255;

    current_align += 4;
    for(size_t a = 0; a < 100; ++a)
    {
        current_align = JointTrajectoryPoint::getMaxCdrSerializedSize(current_align);}


    return current_align;
}

void JointTrajectory::serialize(eprosima::fastcdr::FastCdr &scdr) const
{
    scdr << m_header;

    if(m_joint_names.size() <= 100)
    scdr << m_joint_names;
    else
    throw BadParamException(std::string("The maximum length was exceeded"));
    if(m_points.size() <= 100)
    scdr << m_points;
    else
    throw BadParamException(std::string("The maximum length was exceeded"));
}

void JointTrajectory::deserialize(eprosima::fastcdr::FastCdr &dcdr)
{
    dcdr >> m_header;
    dcdr >> m_joint_names;
    dcdr >> m_points;
}
