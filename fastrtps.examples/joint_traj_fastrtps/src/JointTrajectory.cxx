// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file JointTrajectory.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "JointTrajectory.h"

#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

namespace MyMsg
{

    duration::duration()
    {
        m_sec = 0;
        m_nsec = 0;
    }

    duration::~duration()
    {
    }

    duration::duration(const duration &x)
    {
        m_sec = x.m_sec;
        m_nsec = x.m_nsec;
    }

    duration::duration(duration &&x)
    {
        m_sec = x.m_sec;
        m_nsec = x.m_nsec;
    }

    duration& duration::operator=(const duration &x)
    {
        m_sec = x.m_sec;
        m_nsec = x.m_nsec;

        return *this;
    }

    duration& duration::operator=(duration &&x)
    {
        m_sec = x.m_sec;
        m_nsec = x.m_nsec;

        return *this;
    }

    size_t duration::getMaxCdrSerializedSize(size_t current_alignment)
    {
        size_t initial_alignment = current_alignment;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    size_t duration::getCdrSerializedSize(const duration& data, size_t current_alignment)
    {
        size_t initial_alignment = current_alignment;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    void duration::serialize(eprosima::fastcdr::Cdr &scdr) const
    {
        scdr << m_sec;
        scdr << m_nsec;
    }

    void duration::deserialize(eprosima::fastcdr::Cdr &dcdr)
    {
        dcdr >> m_sec;
        dcdr >> m_nsec;
    }

    size_t duration::getKeyMaxCdrSerializedSize(size_t current_alignment)
    {
        size_t current_align = current_alignment;




        return current_align;
    }

    bool duration::isKeyDefined()
    {
        return false;
    }

    void duration::serializeKey(eprosima::fastcdr::Cdr &scdr) const
    {


    }
    JointTrajectoryPoint::JointTrajectoryPoint()
    {





    }

    JointTrajectoryPoint::~JointTrajectoryPoint()
    {
    }

    JointTrajectoryPoint::JointTrajectoryPoint(const JointTrajectoryPoint &x)
    {
        m_positions = x.m_positions;
        m_velocities = x.m_velocities;
        m_accelerations = x.m_accelerations;
        m_effort = x.m_effort;
        m_time_from_start = x.m_time_from_start;
    }

    JointTrajectoryPoint::JointTrajectoryPoint(JointTrajectoryPoint &&x)
    {
        m_positions = std::move(x.m_positions);
        m_velocities = std::move(x.m_velocities);
        m_accelerations = std::move(x.m_accelerations);
        m_effort = std::move(x.m_effort);
        m_time_from_start = std::move(x.m_time_from_start);
    }

    JointTrajectoryPoint& JointTrajectoryPoint::operator=(const JointTrajectoryPoint &x)
    {
        m_positions = x.m_positions;
        m_velocities = x.m_velocities;
        m_accelerations = x.m_accelerations;
        m_effort = x.m_effort;
        m_time_from_start = x.m_time_from_start;

        return *this;
    }

    JointTrajectoryPoint& JointTrajectoryPoint::operator=(JointTrajectoryPoint &&x)
    {
        m_positions = std::move(x.m_positions);
        m_velocities = std::move(x.m_velocities);
        m_accelerations = std::move(x.m_accelerations);
        m_effort = std::move(x.m_effort);
        m_time_from_start = std::move(x.m_time_from_start);

        return *this;
    }

    size_t JointTrajectoryPoint::getMaxCdrSerializedSize(size_t current_alignment)
    {
        size_t initial_alignment = current_alignment;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        current_alignment += (100 * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        current_alignment += (100 * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        current_alignment += (100 * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        current_alignment += (100 * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += duration::getMaxCdrSerializedSize(current_alignment);

        return current_alignment - initial_alignment;
    }

    size_t JointTrajectoryPoint::getCdrSerializedSize(const JointTrajectoryPoint& data, size_t current_alignment)
    {
        size_t initial_alignment = current_alignment;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        current_alignment += (data.positions().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        current_alignment += (data.velocities().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        current_alignment += (data.accelerations().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        current_alignment += (data.effort().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += duration::getCdrSerializedSize(data.time_from_start(), current_alignment);

        return current_alignment - initial_alignment;
    }

    void JointTrajectoryPoint::serialize(eprosima::fastcdr::Cdr &scdr) const
    {
        scdr << m_positions;
        scdr << m_velocities;
        scdr << m_accelerations;
        scdr << m_effort;
        scdr << m_time_from_start;
    }

    void JointTrajectoryPoint::deserialize(eprosima::fastcdr::Cdr &dcdr)
    {
        dcdr >> m_positions;
        dcdr >> m_velocities;
        dcdr >> m_accelerations;
        dcdr >> m_effort;
        dcdr >> m_time_from_start;
    }

    size_t JointTrajectoryPoint::getKeyMaxCdrSerializedSize(size_t current_alignment)
    {
        size_t current_align = current_alignment;







        return current_align;
    }

    bool JointTrajectoryPoint::isKeyDefined()
    {
        return false;
    }

    void JointTrajectoryPoint::serializeKey(eprosima::fastcdr::Cdr &scdr) const
    {





    }
    time::time()
    {
        m_sec = 0;
        m_nsec = 0;
    }

    time::~time()
    {
    }

    time::time(const time &x)
    {
        m_sec = x.m_sec;
        m_nsec = x.m_nsec;
    }

    time::time(time &&x)
    {
        m_sec = x.m_sec;
        m_nsec = x.m_nsec;
    }

    time& time::operator=(const time &x)
    {
        m_sec = x.m_sec;
        m_nsec = x.m_nsec;

        return *this;
    }

    time& time::operator=(time &&x)
    {
        m_sec = x.m_sec;
        m_nsec = x.m_nsec;

        return *this;
    }

    size_t time::getMaxCdrSerializedSize(size_t current_alignment)
    {
        size_t initial_alignment = current_alignment;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    size_t time::getCdrSerializedSize(const time& data, size_t current_alignment)
    {
        size_t initial_alignment = current_alignment;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    void time::serialize(eprosima::fastcdr::Cdr &scdr) const
    {
        scdr << m_sec;
        scdr << m_nsec;
    }

    void time::deserialize(eprosima::fastcdr::Cdr &dcdr)
    {
        dcdr >> m_sec;
        dcdr >> m_nsec;
    }

    size_t time::getKeyMaxCdrSerializedSize(size_t current_alignment)
    {
        size_t current_align = current_alignment;




        return current_align;
    }

    bool time::isKeyDefined()
    {
        return false;
    }

    void time::serializeKey(eprosima::fastcdr::Cdr &scdr) const
    {


    }
    Header::Header()
    {
        m_seq = 0;


    }

    Header::~Header()
    {
    }

    Header::Header(const Header &x)
    {
        m_seq = x.m_seq;
        m_stamp = x.m_stamp;
        m_frame_id = x.m_frame_id;
    }

    Header::Header(Header &&x)
    {
        m_seq = x.m_seq;
        m_stamp = std::move(x.m_stamp);
        m_frame_id = std::move(x.m_frame_id);
    }

    Header& Header::operator=(const Header &x)
    {
        m_seq = x.m_seq;
        m_stamp = x.m_stamp;
        m_frame_id = x.m_frame_id;

        return *this;
    }

    Header& Header::operator=(Header &&x)
    {
        m_seq = x.m_seq;
        m_stamp = std::move(x.m_stamp);
        m_frame_id = std::move(x.m_frame_id);

        return *this;
    }

    size_t Header::getMaxCdrSerializedSize(size_t current_alignment)
    {
        size_t initial_alignment = current_alignment;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += time::getMaxCdrSerializedSize(current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


        return current_alignment - initial_alignment;
    }

    size_t Header::getCdrSerializedSize(const Header& data, size_t current_alignment)
    {
        size_t initial_alignment = current_alignment;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += time::getCdrSerializedSize(data.stamp(), current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.frame_id().size() + 1;


        return current_alignment - initial_alignment;
    }

    void Header::serialize(eprosima::fastcdr::Cdr &scdr) const
    {
        scdr << m_seq;
        scdr << m_stamp;
        scdr << m_frame_id;
    }

    void Header::deserialize(eprosima::fastcdr::Cdr &dcdr)
    {
        dcdr >> m_seq;
        dcdr >> m_stamp;
        dcdr >> m_frame_id;
    }

    size_t Header::getKeyMaxCdrSerializedSize(size_t current_alignment)
    {
        size_t current_align = current_alignment;





        return current_align;
    }

    bool Header::isKeyDefined()
    {
        return false;
    }

    void Header::serializeKey(eprosima::fastcdr::Cdr &scdr) const
    {



    }
    JointTrajectory::JointTrajectory()
    {



    }

    JointTrajectory::~JointTrajectory()
    {
    }

    JointTrajectory::JointTrajectory(const JointTrajectory &x)
    {
        m_header = x.m_header;
        m_joint_names = x.m_joint_names;
        m_points = x.m_points;
    }

    JointTrajectory::JointTrajectory(JointTrajectory &&x)
    {
        m_header = std::move(x.m_header);
        m_joint_names = std::move(x.m_joint_names);
        m_points = std::move(x.m_points);
    }

    JointTrajectory& JointTrajectory::operator=(const JointTrajectory &x)
    {
        m_header = x.m_header;
        m_joint_names = x.m_joint_names;
        m_points = x.m_points;

        return *this;
    }

    JointTrajectory& JointTrajectory::operator=(JointTrajectory &&x)
    {
        m_header = std::move(x.m_header);
        m_joint_names = std::move(x.m_joint_names);
        m_points = std::move(x.m_points);

        return *this;
    }

    size_t JointTrajectory::getMaxCdrSerializedSize(size_t current_alignment)
    {
        size_t initial_alignment = current_alignment;

        current_alignment += Header::getMaxCdrSerializedSize(current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        for (size_t a = 0; a < 100; ++a)
        {
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;
        }
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        for (size_t a = 0; a < 100; ++a)
        {
            current_alignment += JointTrajectoryPoint::getMaxCdrSerializedSize(current_alignment);
        }


        return current_alignment - initial_alignment;
    }

    size_t JointTrajectory::getCdrSerializedSize(const JointTrajectory& data, size_t current_alignment)
    {
        size_t initial_alignment = current_alignment;

        current_alignment += Header::getCdrSerializedSize(data.header(), current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        for (size_t a = 0; a < data.joint_names().size(); ++a)
        {
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.joint_names().at(a).size() + 1;
        }
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        for (size_t a = 0; a < data.points().size(); ++a)
        {
            current_alignment += JointTrajectoryPoint::getCdrSerializedSize(data.points().at(a), current_alignment);
        }


        return current_alignment - initial_alignment;
    }

    void JointTrajectory::serialize(eprosima::fastcdr::Cdr &scdr) const
    {
        scdr << m_header;
        scdr << m_joint_names;
        scdr << m_points;
    }

    void JointTrajectory::deserialize(eprosima::fastcdr::Cdr &dcdr)
    {
        dcdr >> m_header;
        dcdr >> m_joint_names;
        dcdr >> m_points;
    }

    size_t JointTrajectory::getKeyMaxCdrSerializedSize(size_t current_alignment)
    {
        size_t current_align = current_alignment;





        return current_align;
    }

    bool JointTrajectory::isKeyDefined()
    {
        return false;
    }

    void JointTrajectory::serializeKey(eprosima::fastcdr::Cdr &scdr) const
    {



    }

}